#include <cassert>
#include "xf/xf.h"
#include "xf/timeout.h"
#include "xf/initialevent.h"
#include "xf/behavior.h"

XFBehavior::XFBehavior()
{
    pCurrentEvent_ = nullptr;
    pDispatcher_ = interface::XFDispatcher::getInstance();
    deleteOnTerminate_ = false;
}

XFBehavior::~XFBehavior()
{

}

void XFBehavior::startBehavior()
{
    GEN(XFInitialEvent);		//Equivalent to pushEvent(new XFInitialEvent)
}

void XFBehavior::pushEvent(XFEvent *pEvent, bool fromISR)
{
    pEvent->setBehavior(this);
    interface::XFDispatcher::getInstance()->pushEvent(pEvent, fromISR);	//Give the event to the dispatcher
}

bool XFBehavior::deleteOnTerminate() const
{
    return deleteOnTerminate_;
}

void XFBehavior::setDeleteOnTerminate(bool deleteBehaviour)
{
    deleteOnTerminate_ = deleteBehaviour;
}

const XFEvent *XFBehavior::getCurrentEvent() const
{
    return pCurrentEvent_;
}

interface::XFDispatcher *XFBehavior::getDispatcher()
{
    return interface::XFDispatcher::getInstance();
}

const XFTimeout *XFBehavior::getCurrentTimeout()
{
    return (XFTimeout*)pCurrentEvent_;
}

void XFBehavior::setCurrentEvent(const XFEvent *pEvent)
{
    pCurrentEvent_ = pEvent;
}

XFBehavior::TerminateBehavior XFBehavior::process(const XFEvent *pEvent)
{
    this->setCurrentEvent(pEvent);  //Set the current event
    XFEventStatus evS = this->processEvent();           //Process the event

    if(evS.is(eEventStatus::Consumed) && pEvent->deleteAfterConsume())
    {
        delete pEvent;
    }

    if(evS.is(eEventStatus::Terminate) && deleteOnTerminate())
    {
        return true;
    }
    else
    {
        return false;
    }
}

#include <cassert>
#include <config/xf-config.h>

#if (USE_XF_COMMON_DISPATCHER_CLASS != 0)
#if (XF_TRACE_EVENT_PUSH_POP != 0)
    #include "trace/trace.h"
#endif // XF_TRACE_EVENT_PUSH_POP
#include "xf/eventstatus.h"
#include "xf/interface/timeoutmanager.h"
#include "xf/interface/behavior.h"
#include "xf/interface/mutex.h"
#include "dispatcher.h"

using interface::XFTimeoutManager;      // Allows to use expression 'XFTimeoutManager' instead of 'interface::XFTimeoutManager'.
using interface::XFBehavior;            // Expression XFBehavior used in code below is in fact the XFBehavior interface class.
using Mutex = interface::XFMutex;       // Rename XFMutex interface class to Mutex for easier use.

static ::XFDispatcher dispatcher;

interface::XFDispatcher * interface::XFDispatcher::getInstance()
{
    return &dispatcher;
}

XFDispatcher::XFDispatcher()
{

}

XFDispatcher::~XFDispatcher()
{

}

void XFDispatcher::pushEvent(XFEvent *pEvent, bool fromISR)
{
	assert(pEvent != nullptr);	//Event pointer should never be null

    _events.push(pEvent, fromISR);	//Push event to the queue
}

void XFDispatcher::scheduleTimeout(int timeoutId, int interval, interface::XFBehavior *pBehavior)
{
    XFTimeoutManager::getInstance()->scheduleTimeout(timeoutId, interval, pBehavior);
}

void XFDispatcher::unscheduleTimeout(int timeoutId, interface::XFBehavior *pBehavior)
{
    XFTimeoutManager::getInstance()->unscheduleTimeout(timeoutId, pBehavior);
}

void XFDispatcher::executeOnce()
{
    if(_events.empty() == false)    //Do nothing if the queue is empty
    {
        this->dispatchEvent(_events.front());   //Dispatch event
        _events.pop();              			//Pop the event
    }
}

int XFDispatcher::execute(const void *param)
{
    while(true)
    {
        executeOnce();
    }

    return 0;
}

void XFDispatcher::dispatchEvent(const XFEvent *pEvent) const
{
	 assert(pEvent != nullptr);

     interface::XFBehavior::TerminateBehavior x = pEvent->getBehavior()->process(pEvent);

     if(x)
     {
         delete pEvent->getBehavior();
     }
}

#endif // USE_XF_COMMON_DISPATCHER_CLASS

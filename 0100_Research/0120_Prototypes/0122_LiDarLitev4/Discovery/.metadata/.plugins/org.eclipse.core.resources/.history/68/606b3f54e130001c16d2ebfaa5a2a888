#include <cassert>
#include <config/xf-config.h>

#if (USE_XF_IDF_STM32_XF_CLASS != 0)

#include "xf/interface/timeoutmanager.h"
#include "xf/interface/dispatcher.h"
#include "xf/xf.h"

bool XF::isInitialized_ = false;;         ///< Changes from false to true after calling method initialize(int). Used to handle multiple calls to init(int).
bool XF::isRunning_ = false;             ///< Tells if the XF is initialized and running.

using interface::XFTimeoutManager;

void XF_initialize(int timeInterval)
{
    XF::initialize(timeInterval);		//Call C++ equivalent method
}

void XF_exec()
{
    XF::exec();			//Call C++ equivalent method
}

void XF_execOnce()
{
    XF::execOnce();		//Call C++ equivalent method
}

void XF::initialize(int timeInterval, int argc, char *argv[])
{
	if(!isInitialized_)		//Only initialize once
	{

		XFTimeoutManager::getInstance()->initialize(timeInterval);	//Initialize the timeout manager with the tick interval
		XFTimeoutManager::getInstance()->start();					//Start the timer (only with QT)

		isInitialized_ = true;
	}
}

int XF::exec()
{
	return 0;
}

int XF::execOnce()
{
	isRunning_ = true;

	interface::XFDispatcher::getInstance()->executeOnce();	//Execute the event dispatcher

	return 0;
}

bool XF::isRunning()
{
	return isRunning_;
}

// TODO: Implement code for XF class

#endif // USE_XF_IDF_STM32_XF_CLASS


#include <config/xf-config.h>

#if (USE_XF_COMMON_TIMEOUTMANAGER_CLASS != 0)

#include <cassert>
#include "xf/interface/behavior.h"
#include "xf/interface/mutex.h"
#include "timeoutmanager.h"

using Mutex = interface::XFMutex;       // Rename XFMutex interface class to Mutex for easier use.

interface::XFTimeoutManager * interface::XFTimeoutManager::getInstance()
{
    static ::XFTimeoutManager timeoutManager;
    return &timeoutManager;
}

XFTimeoutManager::~XFTimeoutManager()
{

}

void XFTimeoutManager::start(std::function<void (uint32_t)> startTimeoutManagerTimer)
{
    if(startTimeoutManagerTimer)	//Start timer only if function pointer is not null
    {
    	startTimeoutManagerTimer(getTickInterval());
    }
}

void XFTimeoutManager::scheduleTimeout(int32_t timeoutId, int32_t interval, interface::XFBehavior *pBehavior)
{
    addTimeout(new XFTimeout(timeoutId, interval, pBehavior));	//Create a new timeout and add it to the queue
}

void XFTimeoutManager::tick()
{
	if(!timeouts_.empty())	//Tick only if queue is not empty
	{
		timeouts_.front()->substractFromRelTicks(this->getTickInterval());	//Substract the first entry

		while(timeouts_.front()->getRelTicks() <= 0)	//Pop every timeout that timed out
		{
			returnTimeout(timeouts_.front());
			timeouts_.pop_front();
		}
	}
}

XFTimeoutManager::XFTimeoutManager()
{

}

void XFTimeoutManager::addTimeout(XFTimeout *pNewTimeout)
{
	assert(pNewTimeout != nullptr);

    //Sort algorithm
    if(timeouts_.empty() == true)
    {
        timeouts_.push_back(pNewTimeout);	//Push the timeout if it's the first in the queue
    }
    else
    {
        TimeoutList::iterator it;
        bool placed = false;

        for(it = timeouts_.begin(); it != timeouts_.end(); it++)
        {
        	//If the current timeout's relTicks in the queue is bigger than the one of the timeout that
        	//need to be added, it means the new timeout can be placed before the current timeout.
            if((*it)->getRelTicks() > pNewTimeout->getRelTicks())
            {
                (*it)->substractFromRelTicks(pNewTimeout->getRelTicks());
                placed = true;
                break;
            }
            //If the new timeout cannot be placed, substract the current timeout's relTicks to the new
            //timeout.
            else
            {
                pNewTimeout->substractFromRelTicks((*it)->getRelTicks());
            }
        }

        //If the new timeout hasn't found a place in the queue, it means it needs to be placed at the end.
        if(placed)
        {
            timeouts_.insert(it, pNewTimeout);
        }
        else
        {
            timeouts_.push_back(pNewTimeout);
        }
    }
}

void XFTimeoutManager::unscheduleTimeout(int32_t timeoutId, interface::XFBehavior *pBehavior)
{
    TimeoutList::iterator it, toDelete;

    for(it = timeouts_.begin(); it != timeouts_.end(); it++)
    {
    	//Check if the timeout to delete is exactly the same as provided.
        if((*it)->getId() == timeoutId && pBehavior == (*it)->getBehavior())
        {
            toDelete = it;
        }
    }

    //Delete the timeout
    timeouts_.erase(toDelete);
    delete (*toDelete);
}

void XFTimeoutManager::returnTimeout(XFTimeout *pTimeout)
{
	assert(pTimeout != nullptr);

	//Push the event to its state machine.
    pTimeout->getBehavior()->pushEvent(pTimeout);
}

#endif // USE_XF_COMMON_TIMEOUTMANAGER_CLASS
